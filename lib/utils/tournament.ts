// Tournament Utility Functions
// Business logic utilities for tournament operations

import { 
  Tournament, 
  TournamentType, 
  TournamentStatus, 
  TournamentParticipant, 
  TournamentResult, 
  TournamentStanding,
  MatchOutcome,
  PlayerResults
} from '@/lib/types/tournament';

/**
 * Check if a tournament is upcoming
 * @param tournament - Tournament object
 * @returns True if tournament is upcoming and start date is in the future
 */
export const isUpcoming = (tournament: Tournament): boolean => {
  return tournament.status === TournamentStatus.UPCOMING && 
         new Date(tournament.start_date) > new Date();
};

export const isOngoing = (tournament: Tournament): boolean => {
  return tournament.status === TournamentStatus.ONGOING;
};

export const isCompleted = (tournament: Tournament): boolean => {
  return tournament.status === TournamentStatus.COMPLETED;
};

/**
 * Check if registration is available for a tournament
 * @param tournament - Tournament object
 * @returns True if registration is open and tournament has capacity
 */
export const canRegister = (tournament: Tournament): boolean => {
  return tournament.registration_open && 
         tournament.status === TournamentStatus.UPCOMING &&
         (!tournament.max_players || tournament.current_players < tournament.max_players);
};

// Note: official_tournament_id comes from TDF files uploaded by users, not generated by the system

/**
 * Validate tournament ID format
 * @param id - Tournament ID to validate
 * @returns True if ID matches YY-MM-XXXXXX format
 */
export const validateTournamentId = (id: string): boolean => {
  const regex = /^\d{2}-\d{2}-\d{6}$/;
  return regex.test(id);
};

// Results Calculation Utilities
export const calculatePoints = (wins: number, losses: number, draws: number): number => {
  // Standard Pokemon tournament scoring: 3 points for win, 1 for draw, 0 for loss
  return (wins * 3) + (draws * 1);
};

export const calculatePlayerResults = (matches: Record<string, unknown>[], playerId: string): PlayerResults[string] => {
  const results = {
    wins: 0,
    losses: 0,
    draws: 0,
    byes: 0,
  };

  matches.forEach(match => {
    if (match.player1_id === playerId || match.player2_id === playerId) {
      switch (match.outcome) {
        case MatchOutcome.PLAYER1_WINS:
          if (match.player1_id === playerId) results.wins++;
          else results.losses++;
          break;
        case MatchOutcome.PLAYER2_WINS:
          if (match.player2_id === playerId) results.wins++;
          else results.losses++;
          break;
        case MatchOutcome.DRAW:
          results.draws++;
          break;
        case MatchOutcome.BYE:
          results.byes++;
          break;
        case MatchOutcome.DOUBLE_LOSS:
          results.losses++;
          break;
      }
    }
  });

  return results;
};

export const generateStandings = (
  participants: TournamentParticipant[], 
  results: TournamentResult[]
): TournamentStanding[] => {
  const standings: TournamentStanding[] = participants.map(participant => {
    const result = results.find(r => r.participant_id === participant.id);
    
    return {
      participant_id: participant.id,
      player_name: participant.player_name,
      player_id: participant.player_id,
      wins: result?.wins || 0,
      losses: result?.losses || 0,
      draws: result?.draws || 0,
      byes: result?.byes || 0,
      points: result?.points || 0,
      final_standing: result?.final_standing || 0,
    };
  });

  // Sort by points (descending), then by wins (descending)
  standings.sort((a, b) => {
    if (a.points !== b.points) return b.points - a.points;
    if (a.wins !== b.wins) return b.wins - a.wins;
    return a.losses - b.losses; // Fewer losses is better
  });

  // Assign standings
  standings.forEach((standing, index) => {
    standing.final_standing = index + 1;
  });

  return standings;
};

// Tournament Capacity Utilities
export const getCapacityInfo = (tournament: Tournament) => {
  const { current_players, max_players } = tournament;
  const hasLimit = max_players && max_players > 0;
  const isFull = hasLimit && current_players >= max_players;
  const spotsLeft = hasLimit ? max_players - current_players : null;
  const capacityPercentage = hasLimit ? (current_players / max_players) * 100 : 0;

  return {
    current: current_players,
    max: max_players,
    hasLimit,
    isFull,
    spotsLeft,
    capacityPercentage,
    capacityText: hasLimit 
      ? `${current_players}/${max_players} jugadores`
      : `${current_players} jugadores`,
  };
};

// Search and Filter Utilities
export const filterTournaments = (
  tournaments: Tournament[],
  filters: {
    query?: string;
    type?: TournamentType;
    status?: TournamentStatus;
    city?: string;
    country?: string;
  }
): Tournament[] => {
  return tournaments.filter(tournament => {
    // Text search
    if (filters.query) {
      const query = filters.query.toLowerCase();
      const searchText = `${tournament.name} ${tournament.city} ${tournament.country}`.toLowerCase();
      if (!searchText.includes(query)) return false;
    }

    // Type filter
    if (filters.type && tournament.tournament_type !== filters.type) {
      return false;
    }

    // Status filter
    if (filters.status && tournament.status !== filters.status) {
      return false;
    }

    // Location filters
    if (filters.city && tournament.city.toLowerCase() !== filters.city.toLowerCase()) {
      return false;
    }

    if (filters.country && tournament.country.toLowerCase() !== filters.country.toLowerCase()) {
      return false;
    }

    return true;
  });
};

// Tournament URL Utilities
export const getTournamentUrl = (tournamentId: string): string => {
  return `/tournaments/${tournamentId}`;
};

export const getTournamentManageUrl = (tournamentId: string): string => {
  return `/tournaments/${tournamentId}/manage`;
};

export const getTournamentResultsUrl = (tournamentId: string): string => {
  return `/tournaments/${tournamentId}/results`;
};

// Validation Utilities
export const isValidPlayerCount = (count: number, tournamentType: TournamentType): boolean => {
  // Minimum 4 players for any tournament
  if (count < 4) return false;
  
  // Maximum varies by tournament type
  const maxPlayers: Record<TournamentType, number> = {
    [TournamentType.TCG_PRERELEASE]: 64,
    [TournamentType.TCG_LEAGUE_CHALLENGE]: 32,
    [TournamentType.TCG_LEAGUE_CUP]: 128,
    [TournamentType.VGC_PREMIER_EVENT]: 256,
    [TournamentType.GO_PREMIER_EVENT]: 128,
  };
  
  return count <= maxPlayers[tournamentType];
};

export const getRecommendedRounds = (playerCount: number): number => {
  // Swiss tournament round recommendations
  if (playerCount <= 8) return 3;
  if (playerCount <= 16) return 4;
  if (playerCount <= 32) return 5;
  if (playerCount <= 64) return 6;
  if (playerCount <= 128) return 7;
  return 8;
};

/**
 * Tournament utilities object for easier importing
 * Note: For status and formatting functions, use TournamentStatusManager and useTournamentFormatting
 */
export const TournamentUtils = {
  isUpcoming,
  isOngoing,
  isCompleted,
  canRegister,
  validateTournamentId,
  calculatePoints,
  calculatePlayerResults,
  generateStandings,
  getCapacityInfo,
  filterTournaments,
  getTournamentUrl,
  getTournamentManageUrl,
  getTournamentResultsUrl,
  isValidPlayerCount,
  getRecommendedRounds,
};